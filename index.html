<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Roster Calendar Importer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 720px; margin: 20px auto; padding: 0 16px; }
    h1 { font-size: 22px; margin: 0 0 12px; }
    .row { margin: 10px 0; }
    label { display:block; font-weight:600; margin-bottom:6px; }
    input[type="file"], input[type="text"] { width:100%; padding:10px; font-size:16px; }
    button { padding: 10px 14px; font-size: 16px; cursor:pointer; margin-right:8px; margin-top:8px; }
    #status { margin-top: 12px; padding: 10px; border-radius: 6px; display:none; white-space: pre-wrap; }
    .ok { background:#e8fff0; border:1px solid #34c759; }
    .err { background:#ffecec; border:1px solid #ff3b30; }
    .hint { color:#555; font-size: 13px; line-height:1.4; }
  </style>
</head>
<body>
  <h1>Roster Calendar Importer</h1>

  <div class="row">
    <label for="upload">Excel roster file (.xlsx)</label>
    <input type="file" id="upload" accept=".xlsx,.xls" />
  </div>

  <div class="row">
    <label for="nameInput">Name</label>
    <input type="text" id="nameInput" placeholder='e.g. "Angela Thomson" or "THOMSON, Angela"' autocomplete="off" />
    <div class="hint">Tip: start typing â€” names will match in any order (first/last or "last, first").</div>
  </div>

  <div class="row">
    <button id="btnDownload" disabled>Generate Calendar File</button>
    <button id="btnEmail" disabled>Email (.ics text)</button>
    <button id="btnShare" disabled>Share (.ics file)</button>
  </div>

  <div id="status"></div>

<script>
  let rawGrid = null;          // sheet_to_json(header:1) array-of-arrays
  let staffNames = [];         // col A names
  let dateCols = [];           // [{col, date}] mapping where a date exists for that column

  const uploadEl = document.getElementById('upload');
  const nameEl = document.getElementById('nameInput');
  const btnDownload = document.getElementById('btnDownload');
  const btnEmail = document.getElementById('btnEmail');
  const btnShare = document.getElementById('btnShare');

  uploadEl.addEventListener('change', onFile, false);
  btnDownload.addEventListener('click', () => run('download'));
  btnEmail.addEventListener('click', () => run('email'));
  btnShare.addEventListener('click', () => run('share'));

  function setStatus(msg, ok=true) {
    const el = document.getElementById('status');
    el.style.display = 'block';
    el.className = ok ? 'ok' : 'err';
    el.textContent = msg;
  }

  function normalizeName(s) {
    return (s || '')
      .toString()
      .toLowerCase()
      .replace(/\s+/g,' ')
      .replace(/[.]/g,'')
      .trim();
  }

  // Splits into tokens and ignores commas; supports "last, first" and "first last"
  function tokens(s) {
    return normalizeName(s).split(/[\s,]+/).filter(Boolean);
  }

  function onFile(e) {
    const file = e.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = new Uint8Array(ev.target.result);
        const wb = XLSX.read(data, { type: 'array', cellDates: true });
        const ws = wb.Sheets[wb.SheetNames[0]];
        rawGrid = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true });

        extractNamesAndDates(rawGrid);

        if (!staffNames.length) {
          setStatus('Loaded file, but found no names in column A.', false);
          disableActions();
          return;
        }
        if (!dateCols.length) {
          setStatus('Loaded file, but found no date columns. (This version expects a real date row or Excel-date cells.)', false);
          disableActions();
          return;
        }

        enableActions();
        setStatus(`Loaded ${staffNames.length} names and ${dateCols.length} date columns.`, true);
      } catch (err) {
        console.error(err);
        setStatus('Error reading the Excel file. Please confirm it is a valid .xlsx.', false);
        disableActions();
      }
    };
    reader.readAsArrayBuffer(file);
  }

  function disableActions() {
    btnDownload.disabled = true;
    btnEmail.disabled = true;
    btnShare.disabled = true;
  }
  function enableActions() {
    btnDownload.disabled = false;
    btnEmail.disabled = false;
    btnShare.disabled = false;
  }

  /**
   * DATE DETECTION (robust):
   * - Find the row that contains "SURNAME" (header row).
   * - Then look ABOVE it for a row that has many date-like cells (Date objects or Excel serials).
   * - If not found, also try the header row itself.
   *
   * Your sheet has "SURNAME" and also a "DATE:" line; but the actual per-day columns show day numbers.
   * So we rely on the row with actual Excel date values if present.
   */
  function extractNamesAndDates(grid) {
    staffNames = [];
    dateCols = [];

    // Find header row containing SURNAME
    let headerRow = -1;
    for (let r = 0; r < Math.min(grid.length, 30); r++) {
      const row = grid[r] || [];
      if (row.some(c => typeof c === 'string' && c.toUpperCase().includes('SURNAME'))) {
        headerRow = r; break;
      }
    }
    if (headerRow === -1) return;

    // Candidate rows to search for actual dates
    const candidates = [];
    for (let r = Math.max(0, headerRow - 6); r <= headerRow; r++) candidates.push(r);

    // Pick the row with the most "date-like" cells
    let bestRow = -1, bestCount = 0, bestDates = null;

    for (const r of candidates) {
      const row = grid[r] || [];
      const found = findDateCellsInRow(row);
      if (found.count > bestCount) {
        bestCount = found.count;
        bestRow = r;
        bestDates = found.dates;
      }
    }

    if (bestRow !== -1 && bestCount >= 5) {
      dateCols = bestDates;
    }

    // Extract staff names from col A below headerRow
    for (let r = headerRow + 1; r < grid.length; r++) {
      const v = grid[r]?.[0];
      if (typeof v === 'string' && v.trim()) {
        // Stop if we hit totals area sometimes
        const t = v.trim().toUpperCase();
        if (t.startsWith('TOTAL')) break;
        staffNames.push(v.trim());
      }
    }
  }

  function findDateCellsInRow(row) {
    const dates = [];
    let count = 0;

    for (let c = 0; c < row.length; c++) {
      const v = row[c];
      const d = coerceToDate(v);
      if (d) {
        count++;
        dates.push({ col: c, date: d });
      }
    }
    return { count, dates };
  }

  // Accept Date objects OR Excel serial dates OR parseable date strings
  function coerceToDate(v) {
    if (!v) return null;

    if (v instanceof Date && !isNaN(v.getTime())) {
      return new Date(v.getFullYear(), v.getMonth(), v.getDate());
    }

    // Excel serial date number (rough but works)
    if (typeof v === 'number' && v > 20000 && v < 60000) {
      const d = new Date(Math.round((v - 25569) * 86400 * 1000));
      if (d.getFullYear() >= 2000 && d.getFullYear() <= 2100) {
        return new Date(d.getFullYear(), d.getMonth(), d.getDate());
      }
    }

    if (typeof v === 'string') {
      const s = v.trim();
      // Avoid day numbers like "16"
      if (/^\d{1,2}$/.test(s)) return null;
      const parsed = Date.parse(s);
      if (!isNaN(parsed)) {
        const d = new Date(parsed);
        return new Date(d.getFullYear(), d.getMonth(), d.getDate());
      }
    }

    return null;
  }

  function run(mode) {
    if (!rawGrid) {
      setStatus('Please select an Excel file first.', false);
      return;
    }

    const inputName = nameEl.value.trim();
    if (!inputName) {
      setStatus('Please type your name.', false);
      return;
    }

    const match = findBestNameMatch(inputName);
    if (!match) {
      const suggestion = suggestName(inputName);
      setStatus(
        suggestion
          ? `Could not find "${inputName}". Did you mean:\n- ${suggestion}`
          : `Could not find "${inputName}".`,
        false
      );
      return;
    }

    const events = extractEventsForName(match);
    if (!events.length) {
      setStatus(`Found "${match}" but no shifts were detected.`, false);
      return;
    }

    const ics = buildICS(events, `${match} Work Roster`);

    if (mode === 'download') {
      downloadICS(ics, `${safeFile(match)}_Roster.ics`);
      setStatus('ICS generated. If on iPhone: try "Share (.ics file)" or email it to yourself.', true);
      return;
    }

    if (mode === 'share') {
      shareICS(ics, `${safeFile(match)}_Roster.ics`).catch(() => {
        setStatus('Share failed on this device/browser. Try Download or Email.', false);
      });
      return;
    }

    if (mode === 'email') {
      emailICS(ics, match);
      return;
    }
  }

  function findBestNameMatch(input) {
    const inTok = tokens(input);
    // exact
    const exact = staffNames.find(n => normalizeName(n) === normalizeName(input));
    if (exact) return exact;

    // token match in any order
    let best = null, bestScore = 0;
    for (const n of staffNames) {
      const nt = tokens(n);
      const score = inTok.reduce((acc, t) => acc + (nt.some(x => x.includes(t) || t.includes(x)) ? 1 : 0), 0);
      if (score > bestScore) { bestScore = score; best = n; }
    }
    // Require at least 2 token hits if user typed 2+ tokens, else 1
    const required = inTok.length >= 2 ? 2 : 1;
    return bestScore >= required ? best : null;
  }

  function suggestName(input) {
    const it = tokens(input);
    if (!it.length) return null;
    const candidates = staffNames
      .map(n => ({ n, score: tokens(n).filter(t => it.some(x => t.includes(x) || x.includes(t))).length }))
      .sort((a,b) => b.score - a.score);
    return candidates[0]?.score ? candidates[0].n : null;
  }

  function extractEventsForName(name) {
    // Find row where col A equals name (string match)
    const row = rawGrid.find(r => (r?.[0] || '').toString().trim() === name);
    if (!row) return [];

    const events = [];
    for (const dc of dateCols) {
      const cell = row[dc.col];
      if (!cell) continue;
      if (typeof cell !== 'string') continue;

      const ev = parseShiftCell(cell, dc.date);
      if (ev) events.push(ev);
    }
    return events;
  }

  function parseShiftCell(text, baseDate) {
    const t = text.trim();
    if (!t) return null;
    const up = t.toUpperCase();
    if (up === 'X' || up === 'RDO') return null;

    // time range like 0800-1630 (allow optional spaces)
    const m = up.match(/(\d{4})\s*-\s*(\d{4})/);
    const start = new Date(baseDate);
    const end = new Date(baseDate);

    if (m) {
      const sh = parseInt(m[1].slice(0,2), 10), sm = parseInt(m[1].slice(2,4), 10);
      const eh = parseInt(m[2].slice(0,2), 10), em = parseInt(m[2].slice(2,4), 10);
      start.setHours(sh, sm, 0, 0);
      end.setHours(eh, em, 0, 0);
      if (end <= start) end.setDate(end.getDate() + 1);
    } else {
      // treat leave codes etc as all-day-ish block
      start.setHours(9,0,0,0);
      end.setHours(17,0,0,0);
    }

    return {
      summary: `Shift: ${t}`,
      start,
      end
    };
  }

  // iOS-friendlier ICS: CRLF, UID, DTSTAMP, METHOD, escaping
  function buildICS(events, calName) {
    const dtstamp = formatICSDateUTC(new Date());
    const lines = [];
    lines.push('BEGIN:VCALENDAR');
    lines.push('VERSION:2.0');
    lines.push('PRODID:-//Roster Calendar Importer//EN');
    lines.push('CALSCALE:GREGORIAN');
    lines.push('METHOD:PUBLISH');
    lines.push(`X-WR-CALNAME:${escapeICSText(calName)}`);

    events.forEach((ev, idx) => {
      const uid = `${dtstamp}-${idx}-${Math.random().toString(16).slice(2)}@roster-importer`;
      lines.push('BEGIN:VEVENT');
      lines.push(`UID:${uid}`);
      lines.push(`DTSTAMP:${dtstamp}`);
      lines.push(`DTSTART:${formatICSDateUTC(ev.start)}`);
      lines.push(`DTEND:${formatICSDateUTC(ev.end)}`);
      lines.push(`SUMMARY:${escapeICSText(ev.summary)}`);
      lines.push('STATUS:CONFIRMED');
      lines.push('TRANSP:OPAQUE');
      lines.push('END:VEVENT');
    });

    lines.push('END:VCALENDAR');
    return lines.join('\r\n'); // CRLF matters for strict parsers
  }

  function escapeICSText(s) {
    return String(s)
      .replace(/\\/g, '\\\\')
      .replace(/\n/g, '\\n')
      .replace(/,/g, '\\,')
      .replace(/;/g, '\\;');
  }

  function formatICSDateUTC(d) {
    const pad = n => String(n).padStart(2,'0');
    return d.getUTCFullYear()
      + pad(d.getUTCMonth()+1)
      + pad(d.getUTCDate())
      + 'T'
      + pad(d.getUTCHours())
      + pad(d.getUTCMinutes())
      + pad(d.getUTCSeconds())
      + 'Z';
  }
